# -*- coding: utf-8 -*-
"""Graficos.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1YXR-pSQ-_HAaM2Bh-k3NqCE4qWfprjBK
"""

import matplotlib.pyplot as plt
import pandas as pd
from google.colab import files

uploaded = files.upload()

df = pd.read_csv('SeqLinux.csv')

print(df.tail())

import numpy as np

df = pd.read_csv('SeqLinux.csv')

df_filtrado = df[df['Teste'] != 1]

medias = df_filtrado.groupby(['Tamanho', 'Tipo'])['Real'].mean().reset_index()

config = {
    'H': {'nome': 'Híbrido', 'cor': '#E63946', 'estilo': '-', 'marcador': 'o'},
    'O': {'nome': 'OpenMP', 'cor': '#457B9D', 'estilo': '--', 'marcador': 's'},
    'M': {'nome': 'MPI', 'cor': '#124700', 'estilo': '-.', 'marcador': 'D'},
    'S': {'nome': 'Sequencial', 'cor': '#eb6d07', 'estilo': ':', 'marcador': '^'}
}

plt.figure(figsize=(12, 7), dpi=100)

for tipo in medias['Tipo'].unique():
    dados = medias[medias['Tipo'] == tipo]
    estilo = config[tipo]
    plt.plot(dados['Tamanho'], dados['Real'],
            label=estilo['nome'],
            color=estilo['cor'],
            linestyle=estilo['estilo'],
            marker=estilo['marcador'],
            markersize=8,
            linewidth=2,
            markerfacecolor='white',
            markeredgewidth=1.5)

tamanhos = sorted(medias['Tamanho'].unique())
ticks = tamanhos
labels = [f'$2^{{{int(np.log2(t))}}}$' for t in ticks]

plt.xscale('log', base=2)
plt.xticks(ticks, labels, fontsize=12)

plt.xlabel('Tamanho da Matriz (potências de 2)', fontsize=13, labelpad=10)
plt.ylabel('Tempo Médio (segundos)', fontsize=13, labelpad=10)
plt.title('Desempenho Comparativo por Tamanho de Matriz',
          fontsize=15, pad=20, fontweight='bold')

plt.grid(True, which='both', linestyle='--', alpha=0.4)
plt.legend(title='Implementação', title_fontsize=12, fontsize=11,
           framealpha=0.9, shadow=True)

plt.gca().spines['top'].set_visible(False)
plt.gca().spines['right'].set_visible(False)
plt.tight_layout()

plt.show()

df_filtrado = df[df['Teste'] != 1]

medias_user = df_filtrado.groupby(['Tamanho', 'Tipo'])['User'].mean().reset_index()

config = {
    'H': {'nome': 'Híbrido', 'cor': '#E63946', 'estilo': '-', 'marcador': 'o'},
    'O': {'nome': 'OpenMP', 'cor': '#457B9D', 'estilo': '--', 'marcador': 's'},
    'M': {'nome': 'MPI', 'cor': '#124700', 'estilo': '-.', 'marcador': 'D'},
    'S': {'nome': 'Sequencial', 'cor': '#eb6d07', 'estilo': ':', 'marcador': '^'}
}

plt.figure(figsize=(12, 7), dpi=100)

for tipo in medias_user['Tipo'].unique():
    dados = medias_user[medias_user['Tipo'] == tipo]
    estilo = config[tipo]
    plt.plot(dados['Tamanho'], dados['User'],
            label=estilo['nome'],
            color=estilo['cor'],
            linestyle=estilo['estilo'],
            marker=estilo['marcador'],
            markersize=8,
            linewidth=2,
            markerfacecolor='white',
            markeredgewidth=1.5)

tamanhos = sorted(medias_user['Tamanho'].unique())
ticks = tamanhos
labels = [f'$2^{{{int(np.log2(t))}}}$' for t in ticks]

plt.xscale('log', base=2)
plt.xticks(ticks, labels, fontsize=12)

plt.xlabel('Tamanho da Matriz (potências de 2)', fontsize=13, labelpad=10)
plt.ylabel('Tempo de CPU em Modo Usuário (segundos)', fontsize=13, labelpad=10)
plt.title('Desempenho em Tempo de Usuário por Tamanho de Matriz',
          fontsize=15, pad=20, fontweight='bold')

plt.grid(True, which='both', linestyle='--', alpha=0.4)
plt.legend(title='Implementação', title_fontsize=12, fontsize=11,
           framealpha=0.9, shadow=True)

plt.gca().spines['top'].set_visible(False)
plt.gca().spines['right'].set_visible(False)
plt.tight_layout()

plt.show()

df['R_C'] = df['Real'] / df['User']

df_filtrado = df[df['Teste'] != 1]

medias_rc = df_filtrado.groupby(['Tamanho', 'Tipo'])['R_C'].mean().reset_index()

config = {
    'H': {'nome': 'Híbrido', 'cor': '#E63946', 'estilo': '-', 'marcador': 'o'},
    'O': {'nome': 'OpenMP', 'cor': '#457B9D', 'estilo': '--', 'marcador': 's'},
    'M': {'nome': 'MPI', 'cor': '#124700', 'estilo': '-.', 'marcador': 'D'},
    'S': {'nome': 'Sequencial', 'cor': '#eb6d07', 'estilo': ':', 'marcador': '^'}
}

plt.figure(figsize=(12, 6), dpi=120)

for tipo in medias_rc['Tipo'].unique():
    dados = medias_rc[medias_rc['Tipo'] == tipo]
    estilo = config[tipo]
    plt.plot(dados['Tamanho'], dados['R_C'],
            label=estilo['nome'],
            color=estilo['cor'],
            linestyle=estilo['estilo'],
            marker=estilo['marcador'],
            markersize=8,
            linewidth=2)

tamanhos = sorted(medias_rc['Tamanho'].unique())
plt.xscale('log', base=2)
plt.xticks(tamanhos, [f'$2^{{{int(np.log2(t))}}}$' for t in tamanhos], fontsize=12)

plt.axhline(y=1, color='gray', linestyle='--', alpha=0.5)

plt.xlabel('Tamanho da Matriz', fontsize=12)
plt.ylabel('Rácio R/C (Real/User)', fontsize=12)
plt.title('Eficiência Computacional: Rácio entre Tempo Real e Tempo de Usuário',
          fontsize=14, pad=20)

plt.legend(title='Implementação', fontsize=10)
plt.grid(True, linestyle='--', alpha=0.3)

plt.tight_layout()
plt.show()

df_filtrado = df[df['Teste'] != 1]

medias = df_filtrado.groupby(['Tamanho', 'Tipo'])['Real'].mean().unstack()

speedup = medias['S'].values[:, np.newaxis] / medias[['H', 'M', 'O']].values

tamanhos = medias.index
x_pos = np.arange(len(tamanhos))
largura = 0.25

plt.figure(figsize=(12, 6), dpi=120)
cores = ['#E63946', '#2A9D8F', '#457B9D']

for i, tipo in enumerate(['H', 'M', 'O']):
    plt.bar(x_pos + i*largura, speedup[:, i],
            width=largura,
            color=cores[i],
            label={'H': 'Híbrido', 'M': 'MPI', 'O': 'OpenMP'}[tipo],
            edgecolor='white')

plt.axhline(y=1, color='gray', linestyle='--', linewidth=1)

plt.xticks(x_pos + largura, [f'$2^{{{int(np.log2(t))}}}$' for t in tamanhos], fontsize=12)
plt.xlabel('Tamanho da Matriz', fontsize=12)
plt.ylabel('Aceleração (Speedup)', fontsize=12)
plt.title('Ganho de Desempenho Relativo à Implementação Sequencial', fontsize=14, pad=20)

plt.legend(title='Implementação', fontsize=10)
plt.grid(True, axis='y', linestyle='--', alpha=0.3)

plt.tight_layout()
plt.show()

df_filtrado = df[df['Teste'] != 1]
medias = df_filtrado.groupby(['Tamanho', 'Tipo'])['Real'].mean().unstack()

tamanhos = medias.index

base = medias.loc[256]
escalabilidade = base.div(medias) * (tamanhos.values/256)[:, np.newaxis]

plt.figure(figsize=(12, 6), dpi=120)
estilos = {'H': '-o', 'M': '--s', 'O': '-.D'}
cores = {'H': '#E63946', 'M': '#124700', 'O': '#457B9D'}

for tipo in ['H', 'M', 'O']:
    plt.plot(tamanhos, escalabilidade[tipo],
             estilos[tipo],
             color=cores[tipo],
             label={'H': 'Híbrido', 'M': 'MPI', 'O': 'OpenMP'}[tipo],
             markersize=8,
             linewidth=2)

plt.axhline(y=1, color='gray', linestyle='--', alpha=0.5)

plt.xscale('log', base=2)
plt.xticks(tamanhos, [f'$2^{{{int(np.log2(t))}}}$' for t in tamanhos], fontsize=12)
plt.yticks(np.arange(0, 1.2, 0.2), fontsize=10)

plt.xlabel('Tamanho da Matriz', fontsize=12)
plt.ylabel('Eficiência de Escalabilidade (Normalizada)', fontsize=12)
plt.title('Análise de Escalabilidade das Implementações Paralelas', fontsize=14, pad=20)

plt.legend(title='Implementação', fontsize=10)
plt.grid(True, which='both', linestyle='--', alpha=0.3)

plt.tight_layout()
plt.show()

df_filtrado = df[df['Teste'] != 1]

medias_1024 = df_filtrado[df_filtrado['Tamanho'] == 1024].groupby('Tipo')['Real'].mean()

T_seq = medias_1024['S']

n_processos = 2

implementacoes = ['M', 'O', 'H']
nomes = ['MPI', 'OpenMP', 'Híbrido']
cores = ['#2A9D8F', '#457B9D', '#E63946']

speedups = []
eficiencias = []

for tipo in implementacoes:
    T_par = medias_1024[tipo]
    speedup = T_seq / T_par
    eficiencia = speedup / n_processos
    speedups.append(speedup)
    eficiencias.append(eficiencia)

plt.figure(figsize=(10, 5))
bars = plt.bar(nomes, eficiencias, color=cores)

plt.axhline(y=1, color='black', linestyle='--', label='Eficiência Ideal (100%)')

plt.ylabel('Eficiência (E)', fontsize=12)
plt.title('Eficiência Paralela para Matrizes 1024×1024 (2 Threads/Processos)', fontsize=14)
plt.legend()

for bar in bars:
    height = bar.get_height()
    plt.text(bar.get_x() + bar.get_width()/2, height, f'{height:.3f}',
             ha='center', va='bottom', fontsize=11)

plt.show()